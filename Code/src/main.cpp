/// @file     main.cpp
/// @author   Erik ZORZIN
/// @date     30JUL2020
/// @brief    Single 1/2 spin spinor, simulated as a tangle of a 3D continuum body.

// OPENGL:
#define GUI_SIZE_X    800                                                                           // Window x-size [px].
#define GUI_SIZE_Y    600                                                                           // Window y-size [px].
#define GUI_NAME      "SpinorCodes - Spinor"                                                        // Window name.
#define SHADER_VERT   "cross.vert"                                                                  // OpenGL vertex shader.
#define SHADER_GEOM   "cross.geom"                                                                  // OpenGL geometry shader.
#define SHADER_FRAG   "cross.frag"                                                                  // OpenGL fragment shader.

#ifdef __linux__
  #define SHADER_HOME "../Code/shader"                                                              // Linux OpenGL shaders directory.
#endif

#ifdef __APPLE__
  #define SHADER_HOME "../Code/shader"                                                              // Mac OpenGL shaders directory.
#endif

#ifdef WIN32
  #define SHADER_HOME "..\\..\\Code\\shader"                                                        // Windows OpenGL shaders directory.
#endif

// OPENCL:
#define QUEUE_NUM     1                                                                             // Number of OpenCL queues [#].
#define KERNEL_NUM    2                                                                             // Number of OpenCL kernel [#].
#define KERNEL_1_FILE "spinor_kernel_1.cl"                                                          // OpenCL kernel.
#define KERNEL_2_FILE "spinor_kernel_2.cl"                                                          // OpenCL kernel.
#define KERNEL_3_FILE "utilities.cl"                                                                // OpenCL kernel.

#ifdef __linux__
  #define KERNEL_HOME "../Code/kernel"                                                              // Linux OpenCL kernels directory.
#endif

#ifdef __APPLE__
  #define KERNEL_HOME "../Code/kernel"                                                              // Mac OpenCL kernels directory.
#endif

#ifdef WIN32
  #define KERNEL_HOME "..\\..\\Code\\kernel"                                                        // Windows OpenCL kernels directory.
#endif

// INCLUDES:
#include "nu.hpp"                                                                                   // Neutrino's header file.

int main ()
{
  // KERNEL FILES:
  std::string              kernel_home;                                                             // Kernel home directory.
  std::vector<std::string> kernel_1;                                                                // Kernel_1 source files.
  std::vector<std::string> kernel_2;                                                                // Kernel_2 source files.

  // DATA:
  float                    x_min              = -1.0f;                                              // "x_min" spatial boundary [m].
  float                    x_max              = +1.0f;                                              // "x_max" spatial boundary [m].
  float                    y_min              = -1.0f;                                              // "y_min" spatial boundary [m].
  float                    y_max              = +1.0f;                                              // "y_max" spatial boundary [m].
  float                    z_min              = -1.0f;                                              // "z_min" spatial boundary [m].
  float                    z_max              = +1.0f;                                              // "z_max" spatial boundary [m].
  size_t                   nodes_x            = 25;                                                 // Number of nodes in "X" direction [].
  size_t                   nodes_y            = 25;                                                 // Number of nodes in "Y" direction [].
  size_t                   nodes_z            = 25;                                                 // Number of nodes in "Y" direction [].
  size_t                   nodes              = nodes_x * nodes_y * nodes_z;                        // Total # of nodes [#].
  float                    dx                 = (x_max - x_min) / (nodes_x - 1);                    // x-axis mesh spatial size [m].
  float                    dy                 = (y_max - y_min) / (nodes_y - 1);                    // y-axis mesh spatial size [m].
  float                    dz                 = (z_max - z_min) / (nodes_z - 1);                    // z-axis mesh spatial size [m].
  size_t                   i;                                                                       // "x" direction index [].
  size_t                   j;                                                                       // "y" direction index [].
  size_t                   k;                                                                       // "z" direction index [].
  size_t                   gid;                                                                     // Global index [].
  size_t                   face_R             = nodes_x - 1;                                        // Right face index [].
  size_t                   face_U             = nodes_y - 1;                                        // Up face index [].
  size_t                   face_F             = nodes_z - 1;                                        // Front face index [].
  size_t                   face_L             = 0;                                                  // Left face index [].
  size_t                   face_D             = 0;                                                  // Down face index [].
  size_t                   face_B             = 0;                                                  // Back face index [].
  size_t                   neighbour_R;                                                             // Right neighbour index [].
  size_t                   neighbour_U;                                                             // Up neighbour index [].
  size_t                   neighbour_F;                                                             // Front neighbour index [].
  size_t                   neighbour_L;                                                             // Left neighbour index [].
  size_t                   neighbour_D;                                                             // Down neighbour index [].
  size_t                   neighbour_B;                                                             // Back neighbour index [].

  // GUI PARAMETERS (orbit):
  float                    orbit_x_init       = 0.0f;                                               // x-axis orbit initial rotation.
  float                    orbit_y_init       = 0.0f;                                               // y-axis orbit initial rotation.

  // GUI PARAMETERS (pan):
  float                    pan_x_init         = 0.0f;                                               // x-axis pan initial translation.
  float                    pan_y_init         = 0.0f;                                               // y-axis pan initial translation.
  float                    pan_z_init         = -2.0f;                                              // z-axis pan initial translation.

  // GUI PARAMETERS (mouse):
  float                    mouse_orbit_rate   = 1.0f;                                               // Orbit rotation rate [rev/s].
  float                    mouse_pan_rate     = 5.0f;                                               // Pan translation rate [m/s].
  float                    mouse_decaytime    = 1.25f;                                              // Pan LP filter decay time [s].

  // GUI PARAMETERS (gamepad):
  float                    gamepad_orbit_rate = 1.0f;                                               // Orbit angular rate coefficient [rev/s].
  float                    gamepad_pan_rate   = 1.0f;                                               // Pan translation rate [m/s].
  float                    gamepad_decaytime  = 1.25f;                                              // Low pass filter decay time [s].
  float                    gamepad_deadzone   = 0.1f;                                               // Gamepad joystick deadzone [0...1].

  // NEUTRINO:
  neutrino*                bas                = new neutrino ();                                    // Neutrino baseline.
  opengl*                  gui                = new opengl ();                                      // OpenGL context.
  opencl*                  ctx                = new opencl ();                                      // OpenCL context.
  shader*                  S                  = new shader ();                                      // OpenGL shader program.
  queue*                   Q                  = new queue ();                                       // OpenCL queue.
  kernel*                  K1                 = new kernel ();                                      // OpenCL kernel array.
  kernel*                  K2                 = new kernel ();                                      // OpenCL kernel array.
  size_t                   kernel_sx          = nodes;                                              // Kernel dimension "x" [#].
  size_t                   kernel_sy          = 0;                                                  // Kernel dimension "y" [#].
  size_t                   kernel_sz          = 0;                                                  // Kernel dimension "z" [#].

  // NODE KINEMATICS:
  float4G*                 position           = new float4G ();                                     // Position [m].
  float4*                  velocity           = new float4 ();                                      // Velocity [m/s].
  float4*                  acceleration       = new float4 ();                                      // Acceleration [m/s^2].

  // NODE KINEMATICS (INTERMEDIATE):
  float4*                  position_int       = new float4 ();                                      // Position (intermediate) [m].
  float4*                  velocity_int       = new float4 ();                                      // Velocity (intermediate) [m/s].
  float4*                  acceleration_int   = new float4 ();                                      // Acceleration (intermediate) [m/s^2].

  // FABRIC PROPERTIES:
  float                    rho                = 1000.0f;                                            // Space mass density [kg/m^3].
  float                    E                  = 10000.0f;                                           // Space Young modulus [kg/(m*s^2)].
  float                    mu                 = 10000.0f;                                           // Space viscosity [Pa*s].

  // NODE PROPERTIES:
  float                    m                  = rho * dx * dy * dz;                                 // Space mass [kg].
  float                    R0                 = 0.2f;                                               // Particle's radius [m].
  float4G*                 color              = new float4G ();                                     // Color [m].
  float1*                  mass               = new float1 ();                                      // Mass [kg].
  float1*                  radius             = new float1 ();                                      // Particle radius [m]...

  // LINK PROPERTIES:
  float                    K                  = E * dz * dx / dy;                                   // Space elastic constant [kg/s^2].
  float                    C                  = mu * dx * dy * dz;                                  // Space damping [kg*s*m].
  float1*                  friction           = new float1 ();                                      // Friction.
  float4*                  resting            = new float4 ();                                      // Resting distance [m].
  float1*                  stiffness          = new float1 ();                                      // Stiffness.

  // SIMULATION PARAMETERS:
  float                    dt_critical        = sqrt (m / K);                                       // Critical time step [s].
  float                    dt_simulation      = 0.1f * dt_critical;                                 // Simulation time step [s].
  float1*                  time               = new float1 ();                                      // Time [s].

  // MESH CONNECTIVITY:
  int1*                    index_R            = new int1 ();                                        // Right neighbour index [].
  int1*                    index_U            = new int1 ();                                        // Up neighbour index [].
  int1*                    index_F            = new int1 ();                                        // Front neighbour index [].
  int1*                    index_L            = new int1 ();                                        // Left neighbour index [].
  int1*                    index_D            = new int1 ();                                        // Down neighbour index [].
  int1*                    index_B            = new int1 ();                                        // Back neighbour index [].
  float1*                  freedom            = new float1 ();                                      // Freedom/constrain flag [].

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ///////////////////////////////////////// DATA INITIALIZATION //////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  // NODE KINEMATICS:
  position->init (nodes);                                                                           // Initializing position data...
  velocity->init (nodes);                                                                           // Initializing velocity data...
  acceleration->init (nodes);                                                                       // Initializing acceleration data...

  // NODE KINEMATICS (INTERMEDIATE):
  position_int->init (nodes);                                                                       // Initializing intermediate position data...
  velocity_int->init (nodes);                                                                       // Initializing intermediate position data...
  acceleration_int->init (nodes);                                                                   // Initializing intermediate position data...

  // NODE PROPERTIES:
  color->init (nodes);                                                                              // Initializing color data...
  mass->init (nodes);                                                                               // Initializing mass data...
  radius->init (nodes);                                                                             // Initializing radius data...

  // LINK PROPERTIES:
  stiffness->init (nodes);                                                                          // Initializing stiffness data...
  resting->init (nodes);                                                                            // Initializing resiting position data...
  friction->init (nodes);                                                                           // Initializing friction data...

  // MESH CONNECTIVITY:
  index_R->init (nodes);                                                                            // Initializing right neighbour index...
  index_U->init (nodes);                                                                            // Initializing up neighbour index...
  index_F->init (nodes);                                                                            // Initializing front neighbour index...
  index_L->init (nodes);                                                                            // Initializing left neighbour index...
  index_D->init (nodes);                                                                            // Initializing down neighbour index...
  index_B->init (nodes);                                                                            // Initializing back neighbour index...
  freedom->init (nodes);                                                                            // Initializing freedom flag data...

  // TIME:
  time->init (nodes);                                                                               // Initializing time...

  std::cout << "Critical time step = " << dt_critical << "[s]" << std::endl;
  std::cout << "Simulation time step = " << dt_simulation << "[s]" << std::endl;

  for(k = 0; k < nodes_z; k++)
  {
    for(j = 0; j < nodes_y; j++)
    {
      for(i = 0; i < nodes_x; i++)
      {
        // Computing initial mesh connectivity:
        gid                       = (i + 0) + nodes_x * (j + 0) + nodes_x * nodes_y * (k + 0);      // Computing global index...

        neighbour_R               = (i + 1) + nodes_x * (j + 0) + nodes_x * nodes_y * (k + 0);      // Computing right neighbour index...
        neighbour_U               = (i + 0) + nodes_x * (j + 1) + nodes_x * nodes_y * (k + 0);      // Computing up neighbour index...
        neighbour_F               = (i + 0) + nodes_x * (j + 0) + nodes_x * nodes_y * (k + 1);      // Computing front neighbour index...
        neighbour_L               = (i - 1) + nodes_x * (j + 0) + nodes_x * nodes_y * (k + 0);      // Computing left neighbour index...
        neighbour_D               = (i + 0) + nodes_x * (j - 1) + nodes_x * nodes_y * (k + 0);      // Computing down neighbour index...
        neighbour_B               = (i + 0) + nodes_x * (j + 0) + nodes_x * nodes_y * (k - 1);      // Computing front neighbour index...

        freedom->data[gid]        = 1.0f;                                                           // Setting freedom flag...

        // Setting initial position:
        position->data[gid].x     = x_min + i * dx;                                                 // Setting "x" position...
        position->data[gid].y     = y_min + j * dy;                                                 // Setting "y" position...
        position->data[gid].z     = z_min + k * dz;                                                 // Setting "z" position...
        position->data[gid].w     = 1.0f;                                                           // Setting "w" position...

        // Setting initial velocity:
        velocity->data[gid].x     = 0.0f;                                                           // Setting "x" velocity...
        velocity->data[gid].y     = 0.0f;                                                           // Setting "y" velocity...
        velocity->data[gid].z     = 0.0f;                                                           // Setting "z" velocity...
        velocity->data[gid].w     = 1.0f;                                                           // Setting "w" velocity...

        // Setting initial acceleration:
        acceleration->data[gid].x = 0.0f;                                                           // Setting "x" acceleration...
        acceleration->data[gid].y = 0.0f;                                                           // Setting "y" acceleration...
        acceleration->data[gid].z = 0.0f;                                                           // Setting "z" acceleration...
        acceleration->data[gid].w = 1.0f;                                                           // Setting "w" acceleration...

        // Setting initial node properties:
        //color->data[gid].x        = 0.005f*(rand () % 100);                                         // Setting "x" initial color...
        //color->data[gid].y        = 0.005f*(rand () % 100);                                         // Setting "y" initial color...
        //color->data[gid].z        = 0.5f + 0.005f*(rand () % 100);                                  // Setting "z" initial color...
        color->data[gid].x        = 0.0f;
        color->data[gid].y        = 0.0f;
        color->data[gid].z        = 1.0f;
        color->data[gid].w        = 0.8f;                                                           // Setting "w" initial color...

        mass->data[gid]           = m;                                                              // Setting mass...
        radius->data[gid]         = R0;                                                             // Setting particle radius [m]...

        // Setting initial link properties:
        stiffness->data[gid]      = K;                                                              // Setting stiffness...

        resting->data[gid].x      = dx;                                                             // Setting "x" resting position...
        resting->data[gid].y      = dy;                                                             // Setting "y" resting position...
        resting->data[gid].z      = dz;                                                             // Setting "z" resting position...
        resting->data[gid].w      = 1.0f;                                                           // Setting "w" resting position...

        friction->data[gid]       = C;                                                              // Setting friction...

        // Setting time:
        time->data[gid]           = dt_simulation;                                                  // Setting time...

        // When on bulk:
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j != face_D) &&                                                                         // Not on down face.
           (j != face_U) &&                                                                         // Not on up face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        else // When on all faces:
        {
          freedom->data[gid] = 0.0f;                                                                // Setting freedom flag...
        }

        // When on left face (excluding borders and corners):
        if(
           (i == face_L) &&                                                                         // On left face.
           (j != face_D) &&                                                                         // Not on down face.
           (j != face_U) &&                                                                         // Not on up face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front border.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = gid;                                                                 // Setting index to central node...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on right face (excluding borders and corners):
        if(
           (i == face_R) &&                                                                         // On right face.
           (j != face_D) &&                                                                         // Not on down face.
           (j != face_U) &&                                                                         // Not on up face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = gid;                                                                 // Setting index to central node...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on down face (excluding borders and corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j == face_D) &&                                                                         // On down face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on up face (excluding borders and corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j == face_U) &&                                                                         // On up face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on back face (excluding borders and corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j != face_D) &&                                                                         // Not on front face.
           (j != face_U) &&                                                                         // Not on up face.
           (k == face_B)                                                                            // On back face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = gid;                                                                 // Setting index to central node...
        }

        // When on front face (excluding borders and corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j != face_D) &&                                                                         // Not on front face.
           (j != face_U) &&                                                                         // Not on up face.
           (k == face_F)                                                                            // On front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = gid;                                                                 // Setting index to central node...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on left-down edge (excluding corners):
        if(
           (i == face_L) &&                                                                         // On left face.
           (j == face_D) &&                                                                         // On down face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = gid;                                                                 // Setting index to central node...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on left-up edge (excluding corners):
        if(
           (i == face_L) &&                                                                         // On left face.
           (j == face_U) &&                                                                         // On up face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = gid;                                                                 // Setting index to central node...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on right-down edge (excluding corners):
        if(
           (i == face_R) &&                                                                         // On right face.
           (j == face_D) &&                                                                         // On down face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = gid;                                                                 // Setting index to central node...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on right-up edge (excluding corners):
        if(
           (i == face_R) &&                                                                         // On right face.
           (j == face_U) &&                                                                         // On up face.
           (k != face_B) &&                                                                         // Not on back face.
           (k != face_F)                                                                            // Not on front face.
          )
        {
          index_R->data[gid] = gid;                                                                 // Setting index to central node...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on back-down edge (excluding corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j == face_D) &&                                                                         // On down face.
           (k == face_B)                                                                            // On back face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = gid;                                                                 // Setting index to central node...
        }

        // When on back-up edge (excluding corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j == face_U) &&                                                                         // On up face.
           (k == face_B)                                                                            // On back face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = gid;                                                                 // Setting index to central node...
        }

        // When on front-down edge (excluding corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j == face_D) &&                                                                         // On down face.
           (k == face_F)                                                                            // On front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = gid;                                                                 // Setting index to central node...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on front-up edge (excluding corners):
        if(
           (i != face_L) &&                                                                         // Not on left face.
           (i != face_R) &&                                                                         // Not on right face.
           (j == face_U) &&                                                                         // On up face.
           (k == face_F)                                                                            // On front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = gid;                                                                 // Setting index to central node...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on left-down-back corner:
        if(
           (i == face_L) &&                                                                         // On left face.
           (j == face_D) &&                                                                         // On down face.
           (k == face_B)                                                                            // On back face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = gid;                                                                 // Setting index to central node...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = gid;                                                                 // Setting index to central node...
        }

        // When on right-down-back corner:
        if(
           (i == face_R) &&                                                                         // On right face.
           (j == face_D) &&                                                                         // On down face.
           (k == face_B)                                                                            // On back face.
          )
        {
          index_R->data[gid] = gid;                                                                 // Setting index to central node...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = gid;                                                                 // Setting index to central node...
        }

        // When on left-up-back corner:
        if(
           (i == face_L) &&                                                                         // On left face.
           (j == face_U) &&                                                                         // On up face.
           (k == face_B)                                                                            // On back face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = gid;                                                                 // Setting index to central node...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = gid;                                                                 // Setting index to central node...
        }

        // When on right-up-back corner:
        if(
           (i == face_R) &&                                                                         // On right face.
           (j == face_U) &&                                                                         // On up face.
           (k == face_B)                                                                            // On back face.
          )
        {
          index_R->data[gid] = gid;                                                                 // Setting index to central node...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = neighbour_F;                                                         // Setting index to front neighbour...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = gid;                                                                 // Setting index to central node...
        }

        // When on left-down-front corner:
        if(
           (i == face_L) &&                                                                         // On left face.
           (j == face_D) &&                                                                         // On down face.
           (k == face_F)                                                                            // On front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = gid;                                                                 // Setting index to central node...
          index_L->data[gid] = gid;                                                                 // Setting index to central node...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on right-down-front corner:
        if(
           (i == face_R) &&                                                                         // On right face.
           (j == face_D) &&                                                                         // On down face.
           (k == face_F)                                                                            // On front face.
          )
        {
          index_R->data[gid] = gid;                                                                 // Setting index to central node...
          index_U->data[gid] = neighbour_U;                                                         // Setting index to up neighbour...
          index_F->data[gid] = gid;                                                                 // Setting index to central node...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = gid;                                                                 // Setting index to central node...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on left-up-front corner:
        if(
           (i == face_L) &&                                                                         // On left face.
           (j == face_U) &&                                                                         // On up face.
           (k == face_F)                                                                            // On front face.
          )
        {
          index_R->data[gid] = neighbour_R;                                                         // Setting index to right neighbour...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = gid;                                                                 // Setting index to central node...
          index_L->data[gid] = gid;                                                                 // Setting index to central node...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }

        // When on right-up-front corner:
        if(
           (i == face_R) &&                                                                         // On right face.
           (j == face_U) &&                                                                         // On up face.
           (k == face_F)                                                                            // On front face.
          )
        {
          index_R->data[gid] = gid;                                                                 // Setting index to central node...
          index_U->data[gid] = gid;                                                                 // Setting index to central node...
          index_F->data[gid] = gid;                                                                 // Setting index to central node...
          index_L->data[gid] = neighbour_L;                                                         // Setting index to left neighbour...
          index_D->data[gid] = neighbour_D;                                                         // Setting index to down neighbour...
          index_B->data[gid] = neighbour_B;                                                         // Setting index to back neighbour...
        }
      }
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////// NEUTRINO INITIALIZATION /////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  bas->init (QUEUE_NUM, KERNEL_NUM);                                                                // Initializing Neutrino baseline...
  gui->init (
             bas,                                                                                   // Neutrino baseline.
             GUI_SIZE_X,                                                                            // GUI x-size [px].
             GUI_SIZE_Y,                                                                            // GUI y-size [px.]
             GUI_NAME,                                                                              // GUI name.
             orbit_x_init,                                                                          // Initial x-orbit.
             orbit_y_init,                                                                          // Initial y-orbit.
             pan_x_init,                                                                            // Initial x-pan.
             pan_y_init,                                                                            // Initial y-pan.
             pan_z_init                                                                             // Initial z-pan.
            );
  ctx->init (bas, gui, NU_GPU);                                                                     // Initializing OpenCL context...
  S->init (bas, SHADER_HOME, SHADER_VERT, SHADER_GEOM, SHADER_FRAG);                                // Initializing OpenGL shader...
  Q->init (bas);                                                                                    // Initializing OpenCL queue...
  kernel_home = KERNEL_HOME;                                                                        // Setting kernel home directory...
  kernel_1.push_back (KERNEL_3_FILE);                                                               // Setting 1st source file...
  kernel_1.push_back (KERNEL_1_FILE);                                                               // Setting 2nd source file...
  K1->init (bas, kernel_home, kernel_1, kernel_sx, kernel_sy, kernel_sz);                           // Initializing OpenCL kernel K1...
  kernel_2.push_back (KERNEL_3_FILE);                                                               // Setting 1st source file...
  kernel_2.push_back (KERNEL_2_FILE);                                                               // Setting 2nd source file...
  K2->init (bas, kernel_home, kernel_2, kernel_sx, kernel_sy, kernel_sz);                           // Initializing OpenCL kernel K2...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////// SETTING OPENCL KERNEL ARGUMENTS /////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  K1->setarg (position, 0);                                                                         // Setting position kernel argument...
  K1->setarg (color, 1);                                                                            // Setting depth kernel argument...
  K1->setarg (position_int, 2);                                                                     // Setting intermediate position kernel argument...
  K1->setarg (velocity, 3);                                                                         // Setting velocity kernel argument...
  K1->setarg (velocity_int, 4);                                                                     // Setting intermediate velocity kernel argument...
  K1->setarg (acceleration, 5);                                                                     // Setting acceleration kernel argument...
  K1->setarg (acceleration_int, 6);                                                                 // Setting intermediate acceleration kernel argument...
  K1->setarg (stiffness, 7);                                                                        // Setting stiffness kernel argument...
  K1->setarg (resting, 8);                                                                          // Setting resting position kernel argument...
  K1->setarg (friction, 9);                                                                         // Setting friction kernel argument...
  K1->setarg (mass, 10);                                                                            // Setting mass kernel argument...
  K1->setarg (index_R, 11);                                                                         // Setting right neighbour index kernel argument...
  K1->setarg (index_U, 12);                                                                         // Setting up neighbour index kernel argument...
  K1->setarg (index_F, 13);                                                                         // Setting front neighbour index kernel argument...
  K1->setarg (index_L, 14);                                                                         // Setting left neighbour index kernel argument...
  K1->setarg (index_D, 15);                                                                         // Setting down neighbour index kernel argument...
  K1->setarg (index_B, 16);                                                                         // Setting back neighbour index kernel argument...
  K1->setarg (freedom, 17);                                                                         // Setting freedom flag kernel argument...
  K1->setarg (radius, 18);                                                                          // Setting particle radius kernel argument...
  K1->setarg (time, 19);                                                                            // Setting time step kernel argument...

  K2->setarg (position, 0);                                                                         // Setting position kernel argument...
  K2->setarg (color, 1);                                                                            // Setting depth kernel argument...
  K2->setarg (position_int, 2);                                                                     // Setting intermediate position kernel argument...
  K2->setarg (velocity, 3);                                                                         // Setting velocity kernel argument...
  K2->setarg (velocity_int, 4);                                                                     // Setting intermediate velocity kernel argument...
  K2->setarg (acceleration, 5);                                                                     // Setting acceleration kernel argument...
  K2->setarg (acceleration_int, 6);                                                                 // Setting intermediate acceleration kernel argument...
  K2->setarg (stiffness, 7);                                                                        // Setting stiffness kernel argument...
  K2->setarg (resting, 8);                                                                          // Setting resting position kernel argument...
  K2->setarg (friction, 9);                                                                         // Setting friction kernel argument...
  K2->setarg (mass, 10);                                                                            // Setting mass kernel argument...
  K2->setarg (index_R, 11);                                                                         // Setting right neighbour index kernel argument...
  K2->setarg (index_U, 12);                                                                         // Setting up neighbour index kernel argument...
  K2->setarg (index_F, 13);                                                                         // Setting front neighbour index kernel argument...
  K2->setarg (index_L, 14);                                                                         // Setting left neighbour index kernel argument...
  K2->setarg (index_D, 15);                                                                         // Setting down neighbour index kernel argument...
  K2->setarg (index_B, 16);                                                                         // Setting back neighbour index kernel argument...
  K2->setarg (freedom, 17);                                                                         // Setting freedom flag kernel argument...
  K2->setarg (radius, 18);                                                                          // Setting particle radius kernel argument...
  K2->setarg (time, 19);                                                                            // Setting time step kernel argument...

  position->name = "voxel_center";                                                                  // Setting variable name for OpenGL shader...
  color->name    = "voxel_color";                                                                   // Setting variable name for OpenGL shader...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  //////////////////////////////////// WRITING DATA ON OPENCL QUEUE //////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  Q->write (position, 0);                                                                           // Writing position data on queue...
  Q->write (color, 1);                                                                              // Writing depth data on queue...
  Q->write (position_int, 2);                                                                       // Writing intermediate position data on queue...
  Q->write (velocity, 3);                                                                           // Writing velocity data on queue...
  Q->write (velocity_int, 4);                                                                       // Writing intermediate velocity data on queue...
  Q->write (acceleration, 5);                                                                       // Writing acceleration data on queue...
  Q->write (acceleration_int, 6);                                                                   // Writing intermediate acceleration data on queue...
  Q->write (stiffness, 7);                                                                          // Writing stiffness data on queue...
  Q->write (resting, 8);                                                                            // Writing resting position data on queue...
  Q->write (friction, 9);                                                                           // Writing friction data on queue...
  Q->write (mass, 10);                                                                              // Writing mass data on queue...
  Q->write (index_R, 11);                                                                           // Writing right neighbour index on queue...
  Q->write (index_U, 12);                                                                           // Writing up neighbour index on queue...
  Q->write (index_F, 13);                                                                           // Writing front neighbour index on queue...
  Q->write (index_L, 14);                                                                           // Writing left neighbour index on queue...
  Q->write (index_D, 15);                                                                           // Writing down neighbour index on queue...
  Q->write (index_B, 16);                                                                           // Writing back neighbour index on queue...
  Q->write (freedom, 17);                                                                           // Writing freedom flag data on queue...
  Q->write (radius, 18);                                                                            // Writing particle radius data on queue...
  Q->write (time, 19);                                                                              // Writing time step data on queue...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////// SETTING OPENGL SHADER ARGUMENTS ////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  S->setarg (position, 0);                                                                          // Setting shader argument "0"...
  S->setarg (color, 1);                                                                             // Setting shader argument "1"...
  S->build ();                                                                                      // Building shader program...

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  ////////////////////////////////////////// APPLICATION LOOP ////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  while(!gui->closed ())                                                                            // Opening window...
  {
    bas->get_tic ();                                                                                // Getting "tic" [us]...

    gui->clear ();                                                                                  // Clearing gui...
    gui->poll_events ();                                                                            // Polling gui events...

    Q->acquire (position, 0);                                                                       // Acquiring OpenGL/CL shared argument...
    Q->acquire (color, 1);                                                                          // Acquiring OpenGL/CL shared argument...
    ctx->execute (K1, Q, NU_WAIT);                                                                  // Executing OpenCL kernel...
    ctx->execute (K2, Q, NU_WAIT);                                                                  // Executing OpenCL kernel...
    Q->release (position, 0);                                                                       // Releasing OpenGL/CL shared argument...
    Q->release (color, 1);                                                                          // Releasing OpenGL/CL shared argument...

    gui->mouse_navigation (
                           mouse_orbit_rate,                                                        // Orbit angular rate coefficient [rev/s].
                           mouse_pan_rate,                                                          // Pan translation rate [m/s].
                           mouse_decaytime                                                          // Orbit low pass decay time [s].
                          );

    gui->gamepad_navigation (
                             gamepad_orbit_rate,                                                    // Orbit angular rate coefficient [rev/s].
                             gamepad_pan_rate,                                                      // Pan translation rate [m/s].
                             gamepad_decaytime,                                                     // Low pass filter decay time [s].
                             gamepad_deadzone                                                       // Gamepad joystick deadzone [0...1].
                            );

    if(gui->button_CROSS)
    {
      gui->close ();                                                                                // Closing gui...
    }

    gui->plot (S);                                                                                  // Plotting shared arguments...
    gui->refresh ();                                                                                // Refreshing gui...

    bas->get_toc ();                                                                                // Getting "toc" [us]...
  }

  ////////////////////////////////////////////////////////////////////////////////////////////////////
  /////////////////////////////////////////////// CLEANUP ////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////////////////////////////////
  delete bas;                                                                                       // Deleting Neutrino baseline...
  delete gui;                                                                                       // Deleting OpenGL gui...
  delete ctx;                                                                                       // Deleting OpenCL context...

  delete position;                                                                                  // Deleting position data...
  delete color;                                                                                     // Deleting color data...
  delete velocity;                                                                                  // Deleting velocity data...
  delete acceleration;                                                                              // Deleting acceleration data...

  delete position_int;                                                                              // Deleting intermediate position data...
  delete velocity_int;                                                                              // Deleting intermediate velocity data...
  delete acceleration_int;                                                                          // Deleting intermediate acceleration data...

  delete stiffness;                                                                                 // Deleting stiffness data...
  delete resting;                                                                                   // Deleting resting data...
  delete friction;                                                                                  // Deleting friction data...
  delete mass;                                                                                      // Deleting mass data...
  delete radius;                                                                                    // Deleting particle radius data...

  delete index_R;                                                                                   // Deleting right neighbour index...
  delete index_U;                                                                                   // Deleting up neighbour index...
  delete index_F;                                                                                   // Deleting front neighbour index...
  delete index_L;                                                                                   // Deleting left neighbour index...
  delete index_D;                                                                                   // Deleting down neighbour index...
  delete index_B;                                                                                   // Deleting back neighbour index...

  delete freedom;                                                                                   // Deleting freedom flag data...
  delete time;                                                                                      // Deleting time step data...

  delete Q;                                                                                         // Deleting OpenCL queue...
  delete K1;                                                                                        // Deleting OpenCL kernel...
  delete K2;                                                                                        // Deleting OpenCL kernel...

  return 0;
}